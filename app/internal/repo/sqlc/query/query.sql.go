// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package query

import (
	"context"
	"database/sql"
)

const createBoard = `-- name: CreateBoard :one
INSERT INTO boards (id, name)
VALUES (?, ?)
RETURNING id, name, created_at, updated_at
`

type CreateBoardParams struct {
	ID   string
	Name string
}

func (q *Queries) CreateBoard(ctx context.Context, arg CreateBoardParams) (Board, error) {
	row := q.db.QueryRowContext(ctx, createBoard, arg.ID, arg.Name)
	var i Board
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCard = `-- name: CreateCard :one
INSERT INTO cards (id, column_id, title, description, attachments)
VALUES (?, ?, ?, ?, ?)
RETURNING id, column_id, title, description, attachments, created_at, updated_at
`

type CreateCardParams struct {
	ID          string
	ColumnID    string
	Title       string
	Description sql.NullString
	Attachments sql.NullString
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard,
		arg.ID,
		arg.ColumnID,
		arg.Title,
		arg.Description,
		arg.Attachments,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.ColumnID,
		&i.Title,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createColumn = `-- name: CreateColumn :one
INSERT INTO columns (id, board_id, name, position)
VALUES (?, ?, ?, ?)
RETURNING id, board_id, name, position, created_at, updated_at
`

type CreateColumnParams struct {
	ID       string
	BoardID  string
	Name     string
	Position int64
}

func (q *Queries) CreateColumn(ctx context.Context, arg CreateColumnParams) (Column, error) {
	row := q.db.QueryRowContext(ctx, createColumn,
		arg.ID,
		arg.BoardID,
		arg.Name,
		arg.Position,
	)
	var i Column
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Name,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOperation = `-- name: CreateOperation :one
INSERT INTO operations (id, table_name, record_id, operation_type, payload)
VALUES (?, ?, ?, ?, ?)
RETURNING id, table_name, record_id, operation_type, device_id, payload, created_at, updated_at
`

type CreateOperationParams struct {
	ID            string
	TableName     string
	RecordID      string
	OperationType string
	Payload       string
}

func (q *Queries) CreateOperation(ctx context.Context, arg CreateOperationParams) (Operation, error) {
	row := q.db.QueryRowContext(ctx, createOperation,
		arg.ID,
		arg.TableName,
		arg.RecordID,
		arg.OperationType,
		arg.Payload,
	)
	var i Operation
	err := row.Scan(
		&i.ID,
		&i.TableName,
		&i.RecordID,
		&i.OperationType,
		&i.DeviceID,
		&i.Payload,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSettings = `-- name: CreateSettings :one
INSERT INTO settings (id, transcription_method, whisper_binary_path, whisper_model_path, openai_api_key)
VALUES (1, ?, ?, ?, ?)
RETURNING id, transcription_method, whisper_binary_path, whisper_model_path, openai_api_key, created_at, updated_at
`

type CreateSettingsParams struct {
	TranscriptionMethod string
	WhisperBinaryPath   sql.NullString
	WhisperModelPath    sql.NullString
	OpenaiApiKey        sql.NullString
}

func (q *Queries) CreateSettings(ctx context.Context, arg CreateSettingsParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, createSettings,
		arg.TranscriptionMethod,
		arg.WhisperBinaryPath,
		arg.WhisperModelPath,
		arg.OpenaiApiKey,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.TranscriptionMethod,
		&i.WhisperBinaryPath,
		&i.WhisperModelPath,
		&i.OpenaiApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTranscription = `-- name: CreateTranscription :one
INSERT INTO transcriptions (id, board_id, transcription, recording_path, intent, assistant_response)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at
`

type CreateTranscriptionParams struct {
	ID                string
	BoardID           string
	Transcription     string
	RecordingPath     sql.NullString
	Intent            sql.NullString
	AssistantResponse sql.NullString
}

func (q *Queries) CreateTranscription(ctx context.Context, arg CreateTranscriptionParams) (Transcription, error) {
	row := q.db.QueryRowContext(ctx, createTranscription,
		arg.ID,
		arg.BoardID,
		arg.Transcription,
		arg.RecordingPath,
		arg.Intent,
		arg.AssistantResponse,
	)
	var i Transcription
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Transcription,
		&i.RecordingPath,
		&i.Intent,
		&i.AssistantResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBoard = `-- name: DeleteBoard :exec
DELETE FROM boards
WHERE id = ?
`

func (q *Queries) DeleteBoard(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteBoard, id)
	return err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards
WHERE id = ?
`

func (q *Queries) DeleteCard(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const deleteColumn = `-- name: DeleteColumn :exec
DELETE FROM columns
WHERE id = ?
`

func (q *Queries) DeleteColumn(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteColumn, id)
	return err
}

const deleteTranscription = `-- name: DeleteTranscription :exec
DELETE FROM transcriptions
WHERE id = ?
`

func (q *Queries) DeleteTranscription(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTranscription, id)
	return err
}

const getAllOperations = `-- name: GetAllOperations :many

SELECT o.id, o.table_name, o.record_id, o.operation_type, o.device_id, o.payload, o.created_at, o.updated_at
FROM operations o
JOIN (
    SELECT record_id, MAX(created_at) AS max_created_at
    FROM operations
    WHERE created_at > (
        SELECT COALESCE(last_synced_at, 0)
        FROM sync_state
        WHERE sync_state."table_name" = ?
    )
    AND sync_state."table_name" = ?
    GROUP BY record_id
) latest
ON o.record_id = latest.record_id
AND o.created_at = latest.max_created_at
AND o.table_name = ?
ORDER BY o.created_at ASC
`

type GetAllOperationsParams struct {
	TableName   string
	TableName_2 string
	TableName_3 string
}

//	GetAllOperations The one below is faster & better
//
// SELECT * FROM operations
// WHERE created_at > (SELECT last_synced_at FROM sync_state WHERE sync_state."table_name" = ?)
// ORDER BY created_at ASC;
func (q *Queries) GetAllOperations(ctx context.Context, arg GetAllOperationsParams) ([]Operation, error) {
	rows, err := q.db.QueryContext(ctx, getAllOperations, arg.TableName, arg.TableName_2, arg.TableName_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.TableName,
			&i.RecordID,
			&i.OperationType,
			&i.DeviceID,
			&i.Payload,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoard = `-- name: GetBoard :one

SELECT id, name, created_at, updated_at FROM boards
WHERE id = ?
LIMIT 1
`

// Board Functionality
func (q *Queries) GetBoard(ctx context.Context, id string) (Board, error) {
	row := q.db.QueryRowContext(ctx, getBoard, id)
	var i Board
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCard = `-- name: GetCard :one

SELECT id, column_id, title, description, attachments, created_at, updated_at FROM cards
WHERE id = ?
LIMIT 1
`

// Cards Functionality
func (q *Queries) GetCard(ctx context.Context, id string) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.ColumnID,
		&i.Title,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getColumn = `-- name: GetColumn :one

SELECT id, board_id, name, position, created_at, updated_at FROM columns
WHERE id = ?
LIMIT 1
`

// Columns Functionality
func (q *Queries) GetColumn(ctx context.Context, id string) (Column, error) {
	row := q.db.QueryRowContext(ctx, getColumn, id)
	var i Column
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Name,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSettings = `-- name: GetSettings :one

SELECT id, transcription_method, whisper_binary_path, whisper_model_path, openai_api_key, created_at, updated_at FROM settings
WHERE id = 1
LIMIT 1
`

// Settings Functionality
func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.TranscriptionMethod,
		&i.WhisperBinaryPath,
		&i.WhisperModelPath,
		&i.OpenaiApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSyncState = `-- name: GetSyncState :one
SELECT table_name, last_synced_at, last_synced_op_id
FROM sync_state
WHERE table_name = ?
LIMIT 1
`

func (q *Queries) GetSyncState(ctx context.Context, tableName string) (SyncState, error) {
	row := q.db.QueryRowContext(ctx, getSyncState, tableName)
	var i SyncState
	err := row.Scan(&i.TableName, &i.LastSyncedAt, &i.LastSyncedOpID)
	return i, err
}

const getTranscription = `-- name: GetTranscription :one

SELECT id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at FROM transcriptions
WHERE id = ?
LIMIT 1
`

// Transcriptions Functionality
func (q *Queries) GetTranscription(ctx context.Context, id string) (Transcription, error) {
	row := q.db.QueryRowContext(ctx, getTranscription, id)
	var i Transcription
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Transcription,
		&i.RecordingPath,
		&i.Intent,
		&i.AssistantResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTranscriptionByRecordingPath = `-- name: GetTranscriptionByRecordingPath :one
SELECT id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at FROM transcriptions
where recording_path = ? AND board_id = ?
`

type GetTranscriptionByRecordingPathParams struct {
	RecordingPath sql.NullString
	BoardID       string
}

func (q *Queries) GetTranscriptionByRecordingPath(ctx context.Context, arg GetTranscriptionByRecordingPathParams) (Transcription, error) {
	row := q.db.QueryRowContext(ctx, getTranscriptionByRecordingPath, arg.RecordingPath, arg.BoardID)
	var i Transcription
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Transcription,
		&i.RecordingPath,
		&i.Intent,
		&i.AssistantResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllCards = `-- name: ListAllCards :many
SELECT id, column_id, title, description, attachments, created_at, updated_at FROM cards
ORDER BY created_at ASC
`

func (q *Queries) ListAllCards(ctx context.Context) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listAllCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.ColumnID,
			&i.Title,
			&i.Description,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllColumns = `-- name: ListAllColumns :many

SELECT id, board_id, name, position, created_at, updated_at FROM columns
ORDER BY created_at ASC
`

// Export/Sync Functionality
func (q *Queries) ListAllColumns(ctx context.Context) ([]Column, error) {
	rows, err := q.db.QueryContext(ctx, listAllColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Column
	for rows.Next() {
		var i Column
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Name,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTranscriptions = `-- name: ListAllTranscriptions :many
SELECT id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at FROM transcriptions
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAllTranscriptionsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListAllTranscriptions(ctx context.Context, arg ListAllTranscriptionsParams) ([]Transcription, error) {
	rows, err := q.db.QueryContext(ctx, listAllTranscriptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transcription
	for rows.Next() {
		var i Transcription
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Transcription,
			&i.RecordingPath,
			&i.Intent,
			&i.AssistantResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBoards = `-- name: ListBoards :many
SELECT id, name, created_at, updated_at FROM boards
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListBoardsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListBoards(ctx context.Context, arg ListBoardsParams) ([]Board, error) {
	rows, err := q.db.QueryContext(ctx, listBoards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Board
	for rows.Next() {
		var i Board
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCardsByColumn = `-- name: ListCardsByColumn :many
SELECT id, column_id, title, description, attachments, created_at, updated_at FROM cards
WHERE column_id = ?
ORDER BY created_at ASC
`

func (q *Queries) ListCardsByColumn(ctx context.Context, columnID string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsByColumn, columnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.ColumnID,
			&i.Title,
			&i.Description,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listColumnsByBoard = `-- name: ListColumnsByBoard :many
SELECT id, board_id, name, position, created_at, updated_at FROM columns
WHERE board_id = ?
ORDER BY created_at ASC
`

func (q *Queries) ListColumnsByBoard(ctx context.Context, boardID string) ([]Column, error) {
	rows, err := q.db.QueryContext(ctx, listColumnsByBoard, boardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Column
	for rows.Next() {
		var i Column
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Name,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTranscriptionsByBoard = `-- name: ListTranscriptionsByBoard :many
SELECT id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at FROM transcriptions
WHERE board_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTranscriptionsByBoard(ctx context.Context, boardID string) ([]Transcription, error) {
	rows, err := q.db.QueryContext(ctx, listTranscriptionsByBoard, boardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transcription
	for rows.Next() {
		var i Transcription
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Transcription,
			&i.RecordingPath,
			&i.Intent,
			&i.AssistantResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchColumnsByBoardAndName = `-- name: SearchColumnsByBoardAndName :many
SELECT id, board_id, name, position, created_at, updated_at
FROM "columns"
WHERE board_id = ?
  AND name LIKE '%' || ? || '%' COLLATE NOCASE
`

type SearchColumnsByBoardAndNameParams struct {
	BoardID string
	Column2 sql.NullString
}

func (q *Queries) SearchColumnsByBoardAndName(ctx context.Context, arg SearchColumnsByBoardAndNameParams) ([]Column, error) {
	rows, err := q.db.QueryContext(ctx, searchColumnsByBoardAndName, arg.BoardID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Column
	for rows.Next() {
		var i Column
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Name,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBoard = `-- name: UpdateBoard :one
UPDATE boards
SET name = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, created_at, updated_at
`

type UpdateBoardParams struct {
	Name string
	ID   string
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) (Board, error) {
	row := q.db.QueryRowContext(ctx, updateBoard, arg.Name, arg.ID)
	var i Board
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCard = `-- name: UpdateCard :one
UPDATE cards
SET title = ?,
    description = ?,
    attachments = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, column_id, title, description, attachments, created_at, updated_at
`

type UpdateCardParams struct {
	Title       string
	Description sql.NullString
	Attachments sql.NullString
	ID          string
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, updateCard,
		arg.Title,
		arg.Description,
		arg.Attachments,
		arg.ID,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.ColumnID,
		&i.Title,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCardColumn = `-- name: UpdateCardColumn :one
UPDATE cards
SET column_id = ?
WHERE id = ?
RETURNING id, column_id, title, description, attachments, created_at, updated_at
`

type UpdateCardColumnParams struct {
	ColumnID string
	ID       string
}

func (q *Queries) UpdateCardColumn(ctx context.Context, arg UpdateCardColumnParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, updateCardColumn, arg.ColumnID, arg.ID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.ColumnID,
		&i.Title,
		&i.Description,
		&i.Attachments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateColumn = `-- name: UpdateColumn :one
UPDATE columns
SET "name" = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, board_id, name, position, created_at, updated_at
`

type UpdateColumnParams struct {
	Name string
	ID   string
}

func (q *Queries) UpdateColumn(ctx context.Context, arg UpdateColumnParams) (Column, error) {
	row := q.db.QueryRowContext(ctx, updateColumn, arg.Name, arg.ID)
	var i Column
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Name,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSettings = `-- name: UpdateSettings :one
UPDATE settings
SET transcription_method = ?,
    whisper_binary_path = ?,
    whisper_model_path = ?,
    openai_api_key = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
RETURNING id, transcription_method, whisper_binary_path, whisper_model_path, openai_api_key, created_at, updated_at
`

type UpdateSettingsParams struct {
	TranscriptionMethod string
	WhisperBinaryPath   sql.NullString
	WhisperModelPath    sql.NullString
	OpenaiApiKey        sql.NullString
}

func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, updateSettings,
		arg.TranscriptionMethod,
		arg.WhisperBinaryPath,
		arg.WhisperModelPath,
		arg.OpenaiApiKey,
	)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.TranscriptionMethod,
		&i.WhisperBinaryPath,
		&i.WhisperModelPath,
		&i.OpenaiApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSyncState = `-- name: UpdateSyncState :exec
UPDATE sync_state
SET last_synced_at = ?, last_synced_op_id = ?
WHERE table_name = ?
`

type UpdateSyncStateParams struct {
	LastSyncedAt   int64
	LastSyncedOpID string
	TableName      string
}

func (q *Queries) UpdateSyncState(ctx context.Context, arg UpdateSyncStateParams) error {
	_, err := q.db.ExecContext(ctx, updateSyncState, arg.LastSyncedAt, arg.LastSyncedOpID, arg.TableName)
	return err
}

const updateTranscriptionIntent = `-- name: UpdateTranscriptionIntent :one
UPDATE transcriptions
SET intent = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at
`

type UpdateTranscriptionIntentParams struct {
	Intent sql.NullString
	ID     string
}

func (q *Queries) UpdateTranscriptionIntent(ctx context.Context, arg UpdateTranscriptionIntentParams) (Transcription, error) {
	row := q.db.QueryRowContext(ctx, updateTranscriptionIntent, arg.Intent, arg.ID)
	var i Transcription
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Transcription,
		&i.RecordingPath,
		&i.Intent,
		&i.AssistantResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTranscriptionResponse = `-- name: UpdateTranscriptionResponse :one
UPDATE transcriptions
SET assistant_response = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, board_id, transcription, recording_path, intent, assistant_response, created_at, updated_at
`

type UpdateTranscriptionResponseParams struct {
	AssistantResponse sql.NullString
	ID                string
}

func (q *Queries) UpdateTranscriptionResponse(ctx context.Context, arg UpdateTranscriptionResponseParams) (Transcription, error) {
	row := q.db.QueryRowContext(ctx, updateTranscriptionResponse, arg.AssistantResponse, arg.ID)
	var i Transcription
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Transcription,
		&i.RecordingPath,
		&i.Intent,
		&i.AssistantResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSyncState = `-- name: UpsertSyncState :exec
INSERT INTO sync_state (table_name, last_synced_at, last_synced_op_id)
VALUES (?, ?, ?)
ON CONFLICT(table_name)
DO UPDATE SET
  last_synced_at = excluded.last_synced_at,
  last_synced_op_id = excluded.last_synced_op_id
`

type UpsertSyncStateParams struct {
	TableName      string
	LastSyncedAt   int64
	LastSyncedOpID string
}

func (q *Queries) UpsertSyncState(ctx context.Context, arg UpsertSyncStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncState, arg.TableName, arg.LastSyncedAt, arg.LastSyncedOpID)
	return err
}
